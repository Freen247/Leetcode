
### 内存分配
- 微对象 (0, 16B) — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；
- 小对象 [16B, 32KB] — 依次尝试使用线程缓存、中心缓存和堆分配内存；
- 大对象 (32KB, +∞) — 直接在堆上分配内存；
#### 微对象
我们会依次介绍运行时分配微对象、小对象和大对象的过程，梳理内存分配的核心执行流程。

Go 语言运行时将小于 16 字节的对象划分为微对象，它会使用线程缓存上的微分配器提高微对象分配的性能，我们主要使用它来分配较小的字符串以及逃逸的临时变量。微分配器可以将多个较小的内存分配请求合入同一个内存块中，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收。

微分配器管理的对象不可以是指针类型，管理多个对象的内存块大小 maxTinySize 是可以调整的，在默认情况下，内存块的大小为 16 字节。maxTinySize 的值越大，组合多个对象的可能性就越高，内存浪费也就越严重；maxTinySize 越小，内存浪费就会越少，不过无论如何调整，8 的倍数都是一个很好的选择。
#### 小对象
#### 大对象

### 逃逸分析
先说结论
- 不要过早优化，用数据来驱动我们的优化工作。
- 栈空间分配是廉价的，堆空间分配是昂贵的。
- 了解逃逸机制可以让我们写出更高效的代码。
- 指针的使用会导致栈分配更不可行。
- 找到在低效代码块中提供分配控制的 api。
- 在调用频繁的地方慎用 interface。

栈分配廉价，堆分配昂贵

堆比栈昂贵

Go 有两个地方可以分配内存：一个全局堆空间用来动态分配内存，另一个是每个 goroutine 都有的自身栈空间。


逃逸分析的机制，并没有在 Go 语言官方说明上阐述。对 Go 程序员来说，学习这些规则最有效的方式就是凭经验。编译命令 go build -gcflags '-m' 会让编译器在编译时输出逃逸分析的结果。

让我们来看一个例子：


```golang
package main

import "fmt"

func main() {
	x := 42
	fmt.Println(x)
}

```
输出
```golang
.\main.go:7:13: inlining call to fmt.Println
.\main.go:7:13: x escapes to heap //运行时在堆空间上动态分配。
.\main.go:7:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
```
运行`go build -gcflags '-m -m' .\main.go`可以查看变量逃逸倒堆上的原因

- 我们找到的，能引起变量逃逸到堆上的典型情况：
    - 发送指针或带有指针的值到 channel 中。在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。

- 在一个切片上存储指针或带指针的值。一个典型的例子就是 []*string。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。

- slice 的背后数组被重新分配了，因为 append 时可能会超出其容量(cap)。slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。

- 在 interface 类型上调用方法。在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r, 调用 r.Read(b) 会使得 r 的值和切片 b 的背后存储都逃逸掉，所以会在堆上分配。
