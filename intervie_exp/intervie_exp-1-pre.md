
## 当前已做过的项目简述
入职一年左右，互联网行业，技术框架 flask后端+pg数据库+redis，后端开发
负责项目共五个，其中三个为独立一个人后端，两个为辅助后端
### 习得
- 数据库方面
    - 项目和数据库的链接主要是依靠字符串传输+sqlachemy
    - sql写的更加熟练了-基础优化点：
        >本科期间对数据库操作基本无，也涉及不到数据方便的优化或锻炼机会，此方面在入职后进步较大
        - 读写分离
        - 语法的优化，先将需要查询的数据分临时表 (with 语句或者 create temp table-再删除)
        - 索引构建，项目一般使用多个字符串/数字类型混合索引
        - 插入语法一般使用insert on conflict set
            批量插入分多个连接池 批量用一个session写入；
        - 数据库表的构建
            - 头表：主要维度-一般构建用于筛选框主要分类
                - 公司区域一般分 品牌-区域-多个级-门店-仓库/门店等
                - skc/sku的划分 品牌-产品季-产品线-大/中/小类-款-skc-sku等
                - （涉及到用户的一般可用用户区域/性别/年龄等划分，同理）
            - 行表：行表一般属于明细表
                - 公司/门店的行表一般是 区域-仓库/门店-最细粒度一般在1k-2k之间
                - 产品的行表一般是 skc/sku/product_code等-最细粒度一般在100k-200k之间
                - 最大数据量平均在 1m-2m (百万)
        - 数据库写入修改操作
            - 设计多个大表关联的掉异步，消息队列，（已开发独立的任务中心系统）
                - 对数据进行异步校验（是否正确-是否合理等校验）
                - 将数据写入redis缓存
                - 将数据写入数据库多张表
        - 数据库的查询操作
            - 数据分区域查询-比如表格数据表头和数据体一般分开查询，分页/滚动查询
                - 分页可分表，可用offset limit
            - 查询缓存若无则拉数据库同时缓存，key值为某个时间范围和筛选条件
    - inner join; left join/right join; join; full join 区别和性能?
    - sql执行的顺序?
    - pgsql各个索引?
    - 公司有人在探索es系统，因为年底项目开发进度比较紧张还没开始
        - 个人认为/已有研究表明PG的性能是足以支撑现在的数据量的

- 底层项目的构建-分几个模块
    - 中间件的定义：
    - 数据校验对象的构造
    - 前后端相互传参-转成数据对象的中间件
    - CBV/FBV- 视图的构建
        - 构建装饰项目启动import时自动写入蓝图
        - 上述中间件也需要对返回json数据进行组装，并根据范围类型生成返回数据格式
        - 包装flask/django返回头
    - 底层模块
        - 工具模块
            - 数据转化-日期，算数等
        - 日志模块
    - 通过包分成不同的模块对应不同的功能

- 关于python
> python对接的时高效率开发，性能方便缺失有不行，弱数据类型语言
    - python-golang的区别?

    - 基础python高效率的使用
        - 同功能中相对快的语法
            - dict(dict,**{})
            - map/filter
            - 生成式等
        - 可变对象不可变对象
        > 可变对象：list,dict.
        > 不可变对象有:int,string,float,tuple.
            - 描述就是引用后其子元素是否会随复制后的子类改变而改变
                - 最浅显的例子就是元组不可变
                - dict可变，引用（浅复制）后，修改复制后的子元素，父元素会改变
            - 可变对象dict使用比较多就用copy.deepcopy
            - 判断方法其实也比较简单，我一般是用的是是否能作为字典的key值
        - 垃圾回收机制
            - 计数回收-计数机制：python每个元素都是一个对象
                - 在创建-引用-传参-传入容器时+1
                - 在del-赋值-离开作用域-从容器删除时+1
                - 0 时销毁
                - 缺点：循环引用
                    -
                        ```
                        list1 = [] list2 = [] list1.append(list2) list2.append(list1)
                        ```
            - M * S，标记清除-GC算法
                - 对象之间通过指针连在一起，构成有向图，对象构成节点，而引用关系构成边
                - 根对象就是全局变量、调用栈、寄存器
                - 从根对象出发，沿着有向边遍历，可达的（reachable）对象标记，不可达的对象就是要被清除
                - 处理循环引用问题

    - pandas numpy
        - pandas使用的比较多
        - 常规apply-行-列；group by的使用
        - 合并 concat（列合并-排序使用比较多）；merge关联-使用比较多的场景-界面展示多个年份的数据，多线程查询 merge结果
        - melt/unstack使用比较多，特别是涉及到行表，头表的时候
            - 近期在北京出差 很多复杂的界面需要短时间开发出来都使用 很长的sql查询 结果数据用 pandas 的上述语法来进行处理
            - 高峰时间基本上两三天开发一个模块的主界面，后续一天开发一个子界面
            
    - 我个人对go还是很期待的
        - 就性能而言go对比java不相上下，而且go对分布式计算支持比pandas好很多，仔细地研究还没开始。
        - 公司也准备招java工程-整体转java，我个人也开始准备入手go，继续规划自己地职业道路了
    
    

## 网络通信
### socket编程的select和epoll函数
### tcp的拥塞机制


## 数据库
### 数据库三大范式，隔离级别
### pg数据库的索引


# OS系统
## 进程和线程的区别
## 各个排序算法
        冒泡排序	最差、平均O（n^2）,最好O(N)	1
        鸡尾酒排序(双向冒泡排序)	最差、平均O（n^2）,最好O(N)	1
        插入排序	最差、平均O（n^2）,最好O(N)	1
        归并排序	最差、平均、最好O（nlogn）	n
        桶排序	n	k
        基数排序	dn	n
        二叉树排序	nlogn	n
        图书馆排序	nlogn	(1+e)n
    - 冒泡排序
        - 比较相邻的元素。如果第一个比第二个大，就交换它们两个；针对所有的元素重复以上的步骤，除了最后一个；
        - 每一遍比较 最后一个总是最大的
    - 选择排序
        - 找到最小（大）元素，放在起始位置，再从剩余中继续寻找最小（大）元素，然后放到已排序序列的末尾
        - O(n2)
    - 插入排序
        - 第一个元素不管；取出下一个元素，在已经排序的元素序列中从后向前扫描；如果该元素（已排序）大于新元素，将该元素移到下一位置-直到找到已排序的元素小于或者等于新元素的位置；
    - 希尔排序
    - 归并排序
        - 把长度为n的输入序列分成两个长度为n/2的子序列；
        - 对这两个子序列分别采用归并排序（递归）；
        将两个排序好的子序列合并成一个最终的排序序列。
    - 快速排序
    - 堆排序
    - 计数排序
        - 找到待排序的range(min,max+1)-构建字典key为 range(min,max+1)
        - 计数每个key的出现次数
        - 重新生成所有value
    - 桶排序
    - 基数排序
        - 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。
    - 不得不说python sorted 的Timsort算法
        - 利用了归并排序与插入排序
    - 
