## make和new的区别
## 无缓冲的 channel 和 有缓冲的 channel 的区别？
声明阶段，根据缓冲区的大小调用不同的makechan函数

其中后者用于处理缓冲区大小大于 2 的 32 次方的情况，因为这在 Channel 中并不常见

收发元素的类型和缓冲区的大小初始化 runtime.hchan 和缓冲区：

- 如果当前 Channel 中不存在缓冲区，那么就只会为 runtime.hchan 分配一段内存空间；
- 如果当前 Channel 中存储的类型不是指针类型，会为当前的 Channel 和底层的数组分配一块连续的内存空间；
- 默认情况下会单独为 runtime.hchan 和缓冲区分配内存；

发送阶段

- 无缓存-如果当前 Channel 的 recvq 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前 Goroutine 并将其设置成下一个运行的 Goroutine；
- 有缓存-如果 Channel 存在缓冲区并且其中还有空闲的容量，我们会直接将数据存储到缓冲区 sendx 所在的位置上；
- 如果不满足上面的两种情况，会创建一个 runtime.sudog 结构并将其加入 Channel 的 sendq 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；

接受阶段

- 无缓存-如果 Channel 为空，那么会直接调用 runtime.gopark 挂起当前 Goroutine；
- 有缓存-如果 Channel 已经关闭并且缓冲区没有任何数据，runtime.chanrecv 会直接返回；
- 在默认情况下会挂起当前的 Goroutine，将 runtime.sudog 结构加入 recvq 队列并陷入休眠等待调度器的唤醒；
## 协程泄露(Goroutine Leak)？
协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：

- 缺少接收器，导致发送阻塞
    - 这个例子中，每执行一次 query，则启动1000个协程向信道 ch 发送数字 0，但只接收了一次，导致 999 个协程被阻塞，不能退出。

- 缺少发送器，导致接收阻塞
    - 那同样的，如果启动 1000 个协程接收信道的信息，但信道并不会发送那么多次的信息，也会导致接收协程被阻塞，不能退出。

- 死锁(dead lock)
    - 两个或两个以上的协程在执行过程中，由于竞争资源或者由于彼此通信而造成阻塞，这种情况下，也会导致协程被阻塞，不能退出。

- 无限循环(infinite loops)
    - 这个例子中，为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏。

## golang可以限定线程的数量吗

可以使用环境变量 GOMAXPROCS 或 runtime.GOMAXPROCS(num int) 设置，例如：

从官方文档的解释可以看到，GOMAXPROCS 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。

GOMAXPROCS 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。

因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。

## golang语法执行的顺序
import –> const –> var –> init() –> main()
## Go 语言的局部变量分配在栈上还是堆上？
逃逸分析

通俗地讲，逃逸分析就是确定一个变量要放堆上还是栈上，规则如下：
- 是否有在其他地方（非局部）被引用。只要有可能被引用了，那么它一定分配到堆上。否则分配到栈上
- 即使没有被外部引用，但对象过大，无法存放在栈区上。依然有可能分配到堆上


**哪些会被分配到到栈**
- 如果局部变量在函数外部没有引用，则优先放到栈中；
- 如果局部变量在函数外部存在引用，则必定放在堆中；
- 如果局部变量在函数外部没有引用，但是作为`interface{}`传参，则逃逸到堆中-比如`fmt.Print()`，因为fmt.Println的函数参数为interface类型，编译期不能确定其参数的具体类型，所以将其分配于堆上。
- 如果局部变量在函数外部没有引用，但是变量比较大，-通过命令`ulimit -s`可以查看栈的限制；

## 简述go的gc操作
标记清除(Mark-Sweep)+三色标记+屏障（hook）技术

标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：

标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；
清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。

标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。

三色标记算法将程序中的对象分成白色、黑色和灰色三类。

- 白色：不确定对象。
- 灰色：存活对象，子对象待处理。
- 黑色：存活对象。

特性
- 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
- 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径

标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。

三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。

三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：

正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。

为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。

一次完整的 GC 分为四个阶段：

- 清理终止阶段；
    - 暂停程序，所有的处理器在这时会进入安全点（Safe point）；
    - 如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
- 标记阶段；
    - 将状态切换至 _GCmark、开启写屏障、用户程序协助（Mutator Assiste）并将根对象入队；
    - 恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
    - 开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
    - 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
    - 使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
- 标记终止阶段；
    - 暂停程序、将状态切换至 _GCmarktermination 并关闭辅助标记的用户程序；
    - 清理处理器上的线程缓存；
- 清理阶段；
    - 将状态切换至 _GCoff 开始清理阶段，初始化清理状态并关闭写屏障；
    - 恢复用户程序，所有新创建的对象会标记成白色；
    - 后台并发清理所有的内存管理单元，`当 Goroutine 申请新的内存管理单元时就会触发清理`；

## 简述gmp

P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）.

M从P上获得G并执行

- G:表示协程，每个协程有自己的栈空间

- M:抽象化代表内核线程，记录内核线程栈信息，当协程调度到线程时，使用该goroutine自己的栈信息。
    - go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。runtime/debug中的SetMaxThreads函数，设置M的最大数量，一个M阻塞了，会创建新的M。
    - 没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。

- P:代表调度器，负责调度goroutine，维护一个本地goroutine队列，M从P上获得goroutine并执行，同时还负责部分内存的管理。
	- 为啥需要调度器，调度器是为了负责在多个内核线程-多个协程之间进行调度的工作
	- 调度器的功能是把可运行的goroutine分配到工作线程上。
    - P的数量在环境变量$GOMAXPROCS中决定
    - P的创建 在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。

## 简述csp
> https://blog.csdn.net/weixin_41519463/article/details/103848698
主流的一般使用共享内容机制来进行并发

通信顺序进程（Communicating sequential processes，CSP） Go 语言提供了一种不同的并发模型

目前的 Channel 收发操作均遵循了先进先出的设计，具体规则如下：

- 先从 Channel 读取数据的 Goroutine 会先接收到数据；
- 先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；

## 自旋锁和互斥锁和cas
> https://www.jianshu.com/p/f3a6b514ce74

**CAS算法（compare and swap）**
> CAS算法是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数

> 需要读写的内存值V
> 进行比较的值A
> 拟写入的新值B
> 当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

> 自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。
> 自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。
> 自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。
> 自旋锁本身无法保证公平性，同时也无法保证可重入性。
> 基于自旋锁，可以实现具备公平性和可重入性质的锁。

## 简述go的内存分配
内存分配分三类对象

> 默认情况下，内存块的大小为 16 字节
基本知识
> 所有的 Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会分配一个线程缓存 runtime.mcache 用于处理微对象和小对象的分配，它们会持有内存管理单元 runtime.mspan。

> 每个类型的内存管理单元都会管理特定大小的对象，当内存管理单元中不存在空闲对象时，它们会从 runtime.mheap 持有的 134 个中心缓存 runtime.mcentral 中获取新的内存单元，中心缓存属于全局的堆结构体 runtime.mheap，它会从操作系统中申请内存。

> 在 amd64 的 Linux 操作系统上，runtime.mheap 会持有 4,194,304 runtime.heapArena，每个 runtime.heapArena 都会管理 64MB 的内存，单个 Go 语言程序的内存上限也就是 256TB。
- 管理单元 runtime.mspan 
    - 管理特定大小的对象，当内存管理单元中不存在空闲对象时，它们会从 runtime.mheap 获取新的内存单元
- 线程缓存 runtime.mcache 
    - 它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象
    - 每一个线程缓存都持有 68 * 2 个 runtime.mspan；只有当用户程序申请内存时才会从中心缓存获取新的 runtime.mspan 满足内存分配的需求。
    - 初始化时不包含mspan
- 中心缓存 runtime.mcentral 
    - 与线程缓存不同，访问中心缓存中的内存管理单元需要使用互斥锁
    - 各个线程会通过中心缓存获取新的内存单元
    - 每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元mspan。
- 堆页 runtime.mheap
    - 全局存储变量，统一管理

![](https://img.draveness.me/2020-02-29-15829868066479-go-memory-layout.png)

- 微对象 (0, 16B) — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；
    - 通常为较小的字符串或者逃逸的变量-将多个内存分配请求合并到一个内存块中，只有当内存块内所有数据被回收，才会回收数据块
    - 线程缓存 runtime.mcache 找到最大的内存块，如果合适即通过基地址和偏移量找到分配；若不合适，则通过找到内存管理单元runtime.mspan获取并释放新的内存单元
- 小对象 [16B, 32KB] — 依次尝试使用线程缓存、中心缓存和堆分配内存；
    - 从线程缓存、中心缓存或者堆中获取内存管理单元并从内存管理单元找到空闲的内存空间；
    - 调用 runtime.memclrNoHeapPointers 清空空闲内存中的所有数据
- 大对象 (32KB, +∞) — 直接在堆上分配内存；
    - 对于大于 32KB 的大对象会单独处理，我们不会从线程缓存或者中心缓存中获取内存管理单元，而是直接调用 runtime.mcache.allocLarge 分配大片内存：
    - 计算分配该对象所需要的页数，它按照 8KB 的倍数在堆上申请内存：


## make和new的区别
- make 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel；
- new 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针；

我们在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：
```
slice := make([]int, 0, 100)
hash := make(map[int]bool, 10)
ch := make(chan int, 5)
```

在编译期间的类型检查阶段，Go 语言会将代表 make 关键字的 OMAKE 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型的节点，这些节点会调用不同的运行时函数来初始化相应的数据结构。

相比与复杂的 make 关键字，new 的功能就简单多了，它只能接收类型作为参数然后返回一个指向该类型的指针：
```
i := new(int)

var v int
i := &v
```

编译器会在中间代码生成阶段通过以下两个函数处理该关键字：

- cmd/compile/internal/gc.callnew 会将关键字转换成 ONEWOBJ 类型的节点2；
- cmd/compile/internal/gc.state.expr 会根据申请空间的大小分两种情况处理：
    - 如果申请的空间为 0，就会返回一个表示空指针的 zerobase 变量；
    - 在遇到其他情况时会将关键字转换成 runtime.newobject 函数：

需要注意的是，无论是直接使用 new，还是使用 var 初始化变量，它们在编译器看来都是 ONEWOBJ 和 ODCL 节点。如果变量会逃逸到堆上，这些节点在这一阶段都会被 cmd/compile/internal/gc.walkstmt 转换成通过 runtime.newobject 函数并在堆上申请内存：
## select
## panic和recover
