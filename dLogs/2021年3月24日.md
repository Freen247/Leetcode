## 题目收集
> https://github.com/geektutu/interview-questions
> https://zhuanlan.zhihu.com/p/60248566
> https://www.jianshu.com/p/fa696563c38a


### go的runtime是个什么东西？
runtime 描述了程序运行时候执行的软件/指令

go的runtime 实现了垃圾回收，并发控制， 栈管理以及其他一些 Go 语言的关键特性。 runtime 库是每个 Go 程序的一部分，也就是说编译 Go 代码为机器代码时也会将其也编译进来。

在 Go 语言中， runtime 只是提供支持语言特性的库的名称，也就是 Go 程序执行时候使用的库。
### OOM问题？
### golang的协程goroutine
Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。

#### 协程
一个“用户态线程”必须要绑定一个“内核态线程”，这里的的名字是虚构的，实际上这里的用户态线程就是协程

协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。

**what**是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。
每个协程拥有自己的栈空间，在协程切换时候只需要保存协程的上下文，开销要比内核态的线程切换要小很多

**PMG** 模型前身是GM模型

M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。

老调度器有几个缺点：

- 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。
- M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M'。
- 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。


**PMG模型**
go 内部有三个对象： P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）.
![](https://upload-images.jianshu.io/upload_images/11093205-a79d5ae002d02d72.png?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)
- G:表示goroutine，每个goroutine都有自己的栈空间，定时器，初始化的栈空间在2k左右，空间会随着需求增长。

- M:抽象化代表内核线程，记录内核线程栈信息，当goroutine调度到线程时，使用该goroutine自己的栈信息。

- P:代表调度器，负责调度goroutine，维护一个本地goroutine队列，M从P上获得goroutine并执行，同时还负责部分内存的管理。
	- 为啥需要调度器，调度器是为了负责在多个内核线程-多个协程之间进行调度的工作
	- 调度器的功能是把可运行的goroutine分配到工作线程上。

一个cpu对象启一个工作线程M对象，线程去检查并执行goroutine对象。碰到goroutine对象阻塞的时候，会启动一个新的工作线程，以充分利用cpu资源。所有有时候线程对象会比处理器对象多很多

P的数量：

由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。

M的数量:

go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。
runtime/debug中的SetMaxThreads函数，设置M的最大数量
一个M阻塞了，会创建新的M。

M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。
**MP合适被创建**
1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。

2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。

go执行协程的调度分析图

![](https://upload-images.jianshu.io/upload_images/11093205-9bc6e1e4a6d9d341.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
go语言的并发模式
- 传统的多线程共享内存
	- 普通的线程并发模型，就是像Java、C++、或者Python，他们线程间通信都是通过共享内存的方式来进行的。非常典型的方式就是，在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问
	
- CSP（communicating sequential processes）并发模型
	> Do not communicate by sharing memory; instead, share memory by communicating.
	> “不要以共享内存的方式来通信，相反，要通过通信来共享内存。”
	- goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。
	- channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。

#### cpu
cpu是计算机最昂贵的资源
#### 进程
进程是据有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。

从原理角度上看：进程是支持程序执行的一种系统机制，它对处理器上运行程序的活动规律进行抽象。

从实现角度看：进程是一种数据结构，用来准确的刻画运行程序的状态和系统动态变化状况。

**when?**进程在程序运行是会被创建，是os进行资源分配和保护的基本单位；进程是一个 “执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。

**what?**进程是一个实体。每一个进程都有它自己的地址空间

进程包括
- 文本区域（text region）-文本区域存储处理器执行的代码
- 数据区域（data region）-数据区域存储变量和进程执行期间使用的动态分配的内存
- 堆栈（stack region）-堆栈区域存储着活动过程调用的指令和本地变量

进程分类
- 内核系统进程：操作系统用来管理资源的进程，当系统进程处于运行态时，CPU处于管态，系统之间的关系由操作系统负责。
	- 操作访问CPU资源、I/O资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源，用户空间呢就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell脚本”来调用内核空间提供的资源。
- 用户进程：操作系统可以独立执行的的用户程序段，当用户进程处于运行态时，CPU处于目态，用户进程之间的关系由用户负责。

进程控制块（PCB）：为了管理和控制进程，系统在创建每个进程时，都为其开辟一个专用的存储区，用以记录它在系统中的动态特性。系统根据存储区的信息对进程实施控制管理。进程任务完成后，系统收回该存储区，进程随之消亡，这一存储区就是进程控制块
PCB随着进程的创建而建立，撤销而消亡。系统根据PCB感知一个进程的存在，PCB是进程存在的唯一物理标识（这一点可以类比作业控制块JCB）

**why？**
操作系统中引入进程的目的是为了使多个程序并发执行，以便改善资源利用率和提高系统效率

**how**进程间的通信：


#### 线程
**why**
引入线程的原因：把进程的两项功能“独立分配资源”和“被调度分配执行”分离开来，前一项任务仍然由进程完成，作为系统资源分配和保护的独立单位，无须频繁切换；后一项任务交给称作线程的实体来完成，线程作为系统调度和分配的基本单位，会被频繁的调度和切换

**what** 线程，有时被称为轻量进程(Lightweight Process，LWP），是程序执行流的最小单元。是被系统独立调度和分派的基本单位。
线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间

线程/线程之间共享源：进程拥有各自独立的地址空间，资源，所以共享复杂，需要用IPC，同步简单； 线程共享所属进程的资源，共享简单，但同步复杂，要通过加锁等措施。进程独立地址空间，线程共享同一个进程的地址空间
**ipc**IPC，Inter-Process Communication

**线程之间共享的有**
进程的共享堆区-线程又有自己的堆栈

进程代码段、进程的公有数据(利用这些共享的数据，线程很容易实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID和进程组ID。

**线程之间不共享的有**
1. 线程ID
	每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标
识线程。

2. 寄存器组的值
	由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线
程切换到另一个线程上  时，必须将原有的线程的寄存器集合的状态保存，以便
将来该线程在被重新切换到时能得以恢复。

3. 线程的堆栈
	堆栈是保证线程独立运行所必须的。
	线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程
必须拥有自己的函数堆栈，  使得函数调用可以正常执行，不受其他线程的影
响。

4. 错误返回码
	由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用
后设置了errno值，而在该  线程还没有处理这个错误，另外一个线程就在此时
被调度器投入运行，这样错误值就有可能被修改。
	所以，不同的线程应该拥有自己的错误返回码变量。

5. 线程的信号屏蔽码
	由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自
己管理。但所有的线程都  共享同样的信号处理器。

6. 线程的优先级
	由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参
数，这个参数就是线程的 优先级。

**线程中的上下文context**
在并发程序中，由于超时、取消操作或者一些异常情况，往往需要进行抢占操作或者中断后续操作。

举个例子：在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务，用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速中断退出，然后系统才能释放这些 goroutine 占用的资源。

context常用的使用场景：

1) 一个请求对应多个goroutine之间的数据交互

2) 超时控制

3) 上下文控制

### 基础问题
- = 和 := 的区别？
	```
	:= 声明+赋值
	= 仅赋值
	```
- 指针的作用？
	```
	指针用来保存变量的地址。
	var x =  5
	var p *int = &x
	fmt.Printf("x = %d",  *p) // x 可以用 *p 访问
	* 运算符，也称为解引用运算符，用于访问地址中的值。
	＆运算符，也称为地址运算符，用于返回变量的地址。
	```
- golang允许返回多个值吗？可以
- golang传参有默认值吗？没有
- golang没有异常类型，只有错误类型Error
