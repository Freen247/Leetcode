## GC
### 各个语言中的区别

> https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/
C、C++ 以及 Rust 等编程语言使用手动的方式管理内存2，工程师需要主动申请或者释放内存；而 Python、Ruby、Java 和 Go 等语言使用自动的内存管理系统，一般都是垃圾收集机制，不过 Objective-C 却选择了自动引用计数3，虽然引用计数也是自动的内存管理机制

用户程序（Mutator）会通过内存分配器（Allocator）在堆上申请内存，而垃圾收集器（Collector）负责回收堆上的内存空间，内存分配器和垃圾收集器共同管理着程序中的堆内存空间。
```
Mutator->Allocator->mHeap<-Cllector
```

-- ：标记压缩（Mark-Compact）、复制回收（Copying GC）、分代回收（Generational GC）
### 标记清除法
标记清除是跟踪式垃圾收集器

- 标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；
- 清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表；

**标记**，标记存活且空闲的对象，标记后会释放其内存并用链表串联起来

垃圾收集器从垃圾收集的根对象出发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活

标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程需要标记对象的存活状态，用户程序在垃圾收集的过程中也不能执行，为了解决长时间的收集时间的等待，我们需要用到更复杂的机制来解决 STW 的问题。

#### 三色抽象
> https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#%E4%B8%89%E8%89%B2%E6%8A%BD%E8%B1%A1
将对象分为三类
- 白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；
- 黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
- 灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

标记阶段是，垃圾收集器从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。

标记步骤分为：
- 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
- 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
- 重复上述两个步骤直到对象图中不存在灰色对象；


当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾

上述的三色分类中为了保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：

- 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
- 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径
#### 悬挂指针-屏障技术
垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。


悬挂指针是指：本来不应该被回收的对象却被回收了的错误

为了解决这种错误我们采用屏障技术

内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作

屏障技术分为
- 插入写屏障-一种相对保守的屏障技术，它会将有存活可能的对象都标记成灰色以满足强三色不变性。
    > 在一个垃圾收集器和用户程序交替运行的场景中会出现对象指向切换的清空
    - 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；
    - 用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色；
    - 垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；
    > 插入写的问题是，如果指向C的切换为指向B，那系统会继续认为C为存活的，从而被错误的标记知道下次循环才会被回收
- 删除写屏障
    - 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；
    - 用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；
    - 用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色；
    - 垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；
    > 删除写屏障通过对 C 对象的着色，保证了 C 对象和下游的 D 对象能够在这一次垃圾收集的循环中存活，避免发生悬挂指针以保证用户程序的正确性。

垃圾收集器一旦开始执行就会浪费大量的计算资源，为了减少应用程序暂停的最长时间和垃圾收集的总暂停时间，我们会使用下面的策略优化现代的垃圾收集器：

- 增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；
    - 增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间
    - 在收集前打开写屏障，用户程序修改都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性，虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只带来好处的，但是总体来说还是利大于弊。

- 并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；
    - 并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、利用多核优势与用户程序并行执行，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响：
    - 虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。

因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用屏障技术保证垃圾收集的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。

### golang垃圾回收机制的演变过程
最开始的垃圾收集器还是不精确的单线程 STW 收集器，但是最新版本的垃圾收集器却支持并发垃圾收集、去中心化协调等特性
- v1.0 — 完全串行的标记和清除过程，需要暂停整个程序；
- v1.1 — 在多核主机并行执行垃圾收集的标记和清除阶段11；
- v1.3 — 运行时基于只有指针类型的值包含指针的假设增加了对栈内存的精确扫描支持，实现了真正精确的垃圾收集12；
- 将 unsafe.Pointer 类型转换成整数类型的值认定为不合法的，可能会造成悬挂指针等严重问题；
- v1.5 — 实现了基于三色标记清扫的并发垃圾收集器13；
    - 大幅度降低垃圾收集的延迟从几百 ms 降低至 10ms 以下；
    - 计算垃圾收集启动的合适时间并通过并发加速垃圾收集的过程；
    - 实现的并发垃圾收集策略由专门的 Goroutine 负责在处理器之间同步和协调垃圾收集的状态。当其他的 Goroutine 发现需要触发垃圾收集时，它们需要将该信息通知给负责修改状态的主 Goroutine，然而这个通知的过程会带来一定的延迟，这个延迟的时间窗口很可能是不可控的，用户程序会在这段时间继续分配内存。
- v1.6 — 实现了去中心化的垃圾收集协调器；
    - 基于显式的状态机使得任意 Goroutine 都能触发垃圾收集的状态迁移；
    - 使用密集的位图替代空闲链表表示的堆内存，降低清除阶段的 CPU 占用14；
- v1.7 — 通过并行栈收缩将垃圾收集的时间缩短至 2ms 以内15；
- v1.8 — 使用混合写屏障将垃圾收集的时间缩短至 0.5ms 以内16；
- v1.9 — 彻底移除暂停程序的重新扫描栈的过程17；
- v1.10 — 更新了垃圾收集调频器（Pacer）的实现，分离软硬堆大小的目标18；
- v1.12 — 使用新的标记终止算法简化垃圾收集器的几个阶段19；
- v1.13 — 通过新的 Scavenger 解决瞬时内存占用过高的应用程序向操作系统归还内存的问题20；
- v1.14 — 使用全新的页分配器优化内存分配的速度21；

### 回收堆目标
STW 的垃圾收集器虽然需要暂停程序，但是它能够有效地控制堆内存的大小，Go 语言运行时的默认配置会在堆内存达到上一次垃圾收集的 2 倍时，触发新一轮的垃圾收集，这个行为可以通过环境变量 GOGC 调整，在默认情况下它的值为 100，即增长 100% 的堆内存才会触发 GC。

![img](https://img.draveness.me/2020-03-16-15843705141890-concurrent-garbage-collector-heap.png)

Go 语言 v1.5 引入并发垃圾收集器的同时使用垃圾收集调步（Pacing）算法计算触发的垃圾收集的最佳时间，确保触发的时间既不会浪费计算资源，也不会超出预期的堆大小。我们希望尽可能的减少垃圾收集结束时与目标的差值，降低垃圾收集带来的额外开销以及程序的暂停时间。

`垃圾收集调步算法`是跟随 v1.5 一同引入的，该算法的目标是优化堆的增长速度和垃圾收集器的 CPU 利用率23，而在 v1.10 版本中又对该算法进行了优化，将原有的目的堆大小拆分成了软硬两个目标24，因为调整垃圾收集的执行频率涉及较为复杂的公式，对理解垃圾收集原理帮助较为有限，本节就不展开介绍了，感兴趣的读者可以自行阅读。

**混合写屏障**

在 Go 语言 v1.7 版本之前，运行时会使用 Dijkstra 插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的 Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 Goroutine 的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在实现上选择了在标记阶段完成时暂停程序、将所有栈对象标记为灰色并重新扫描，在活跃 Goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。

Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障，该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色：
```
writePointer(slot, ptr):
    shade(*slot)
    if current stack is grey:
        shade(ptr)
    *slot = ptr
```
为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。

### 实现原理

- 垃圾回收机制的启动时会进行如下操作
    >
    - 两次调用 runtime.gcTrigger.test 检查是否满足垃圾收集条件；
    - 暂停程序、在后台启动用于处理标记任务的工作 Goroutine、确定所有内存管理单元都被清理以及其他标记阶段开始前的准备工作；
    - 进入标记阶段、准备后台的标记工作、根对象的标记工作以及微对象、恢复用户程序，进入并发扫描和标记阶段；
- 验证垃圾收集条件的同时，该方法还会在循环中不断调用 runtime.sweepone 清理已经被标记的内存单元，完成上一个垃圾收集循环的收尾工作：
    ```
    func gcStart(trigger gcTrigger) {
        for trigger.test() && sweepone() != ^uintptr(0) {
            sweep.nbgsweep++
        }

        semacquire(&work.startSema)
        if !trigger.test() {
            semrelease(&work.startSema)
            return
        }
        ...
    }
    ```

Go 语言的垃圾收集可以分成清除终止、标记、标记终止和清除四个不同阶段
- 清理终止阶段；
    - 暂停程序，所有的处理器在这时会进入安全点（Safe point）；
    - 如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
- 标记阶段；
    - 将状态切换至 _GCmark、开启写屏障、用户程序协助（Mutator Assiste）并将根对象入队；
    - 恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
    - 开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
    - 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
    - 使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
- 标记终止阶段；
    - 暂停程序、将状态切换至 _GCmarktermination 并关闭辅助标记的用户程序；
    - 清理处理器上的线程缓存；
- 清理阶段；
    - 将状态切换至 _GCoff 开始清理阶段，初始化清理状态并关闭写屏障；
    - 恢复用户程序，所有新创建的对象会标记成白色；
    - 后台并发清理所有的内存管理单元，`当 Goroutine 申请新的内存管理单元时就会触发清理`；


`垃圾回收器触发的时机`：允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环

除了这种这种后台系统监控触发的垃圾收集器外，在1.16版本新增了两种方法触发垃圾收集器

- 后台强制触发-运行时会在应用程序启动时在后台开启一个用于强制触发垃圾收集的 Goroutine，该 Goroutine 的职责非常简单 — 调用 runtime.gcStart 尝试启动新一轮的垃圾收集：
- 手动触发-用户程序会通过 runtime.GC 函数在程序运行期间主动通知运行时执行，该方法在调用时会阻塞调用方直到当前垃圾收集循环完成，在垃圾收集期间也可能会通过 STW 暂停整个程序：
    - 手动触发垃圾收集的过程不是特别常见，一般只会在运行时的测试代码中才会出现，不过如果我们认为触发主动垃圾收集是有必要的，我们也可以直接调用该方法，但是作者并不认为这是一种推荐的做法。

垃圾收集是一门非常古老的技术，它的执行速度和利用率很大程度上决定了程序的运行速度，Go 语言为了实现高性能的并发垃圾收集器，使用三色抽象、并发增量回收、混合写屏障、调步算法以及用户程序协助等机制将垃圾收集的暂停时间优化至毫秒级以下，从早期的版本看到今天，我们能体会到其中的工程设计和演进，作者觉得研究垃圾收集的是实现原理还是非常值得的。

> 就研究到这了-如果面试问的再深，那只能说我再学两年再来吧，看别的去了，太深了。
### 为何手动触发垃圾回收机制不是一种推荐的做法？


## 收集一些题目
### 什么是 rune 类型
byte数据类型与rune相似，它们都是用来表示字符类型的变量类型。它们的不同在于：

byte 等同于int8，常用来处理ascii字符
rune 等同于int32,常用来处理unicode或utf-8字符

ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。

Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。例如下面的例子中 语 和 言 使用 UTF-8 编码后各占 3 个 byte，因此 len("Go语言") 等于 8，当然我们也可以将字符串转换为 rune 序列。
```
package main

import (
    "fmt"
    "unicode/utf8"
)

func main() {

    var str = "hello 你好"

    //golang中string底层是通过byte数组实现的，座椅直接求len 实际是在按字节长度计算  所以一个汉字占3个字节算了3个长度
    fmt.Println("len(str):", len(str))
    
    //以下两种都可以得到str的字符串长度
    
    //golang中的unicode/utf8包提供了用utf-8获取长度的方法
    fmt.Println("RuneCountInString:", utf8.RuneCountInString(str))

    //通过rune类型处理unicode字符
    fmt.Println("rune:", len([]rune(str)))
}
```
运行结果
```
len(str): 12
RuneCountInString: 8
rune: 8
```
### 如何判断 map 中是否包含某个 key ？
```
if val, ok := dict["foo"]; ok {
    //do something here
}
```
dict["foo"] 有 2 个返回值，val 和 ok，如果 ok 等于 true，则说明 dict 包含 key "foo"，val 将被赋予 "foo" 对应的值。
### Go 支持默认参数或可选参数吗？
Go 语言不支持可选参数（python 支持），也不支持方法重载（java支持）。

### go如何交换两个变量的值
```

a, b := "A", "B"
a, b = b, a
fmt.Println(a, b) // B A
```

### struct中tag的作用
```

package main

import "fmt"
import "encoding/json"

type Stu struct {
	Name string `json:"stu_name"`
	ID   string `json:"stu_id"`
	Age  int    `json:"-"`
}

func main() {
	buf, _ := json.Marshal(Stu{"Tom", "t001", 18})
	fmt.Printf("%s\n", buf)
}
```
这个例子使用 tag 定义了结构体字段与 json 字段的转换关系，Name -> stu_name, ID -> stu_id，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 json 文本之间的转换。

### 如何判断 2 个字符串切片（slice) 是相等的？
go 语言中可以使用反射 reflect.DeepEqual(a, b) 判断 a、b 两个切片是否相等，但是通常不推荐这么做，使用反射非常影响性能。

如果两个slice是byte类型还可以用bytes.Equal(a, b)比较
```
package main

import (
    "bytes"
    "fmt"
)

func main() {
    a := []byte{0, 1, 3, 2}
    b := []byte{0, 1, 3, 2}
    c := []byte{1, 1, 3, 2}

    fmt.Println(bytes.Equal(a, b))
    fmt.Println(bytes.Equal(a, c))
}
```
遍历比较
```
func StringSliceEqualBCE(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }

    if (a == nil) != (b == nil) {
        return false
    }

    b = b[:len(a)]
    for i, v := range a {
        if v != b[i] {
            return false
        }
    }

    return true
}
```
### 空struct{}的用途
使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。
```
fmt.Println(unsafe.Sizeof(struct{}{})) // 0
```

比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。
```
type Set map[string]struct{}

func main() {
	set := make(Set)

	for _, item := range []string{"A", "A", "B", "C"} {
		set[item] = struct{}{}
	}
	fmt.Println(len(set)) // 3
	if _, ok := set["A"]; ok {
		fmt.Println("A exists") // A exists
	}
}
```
再比如，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。
```
func main() {
	ch := make(chan struct{}, 1)
	go func() {
		<-ch
		// do something
	}()
	ch <- struct{}{}
	// ...
}
```
### init() 函数是什么时候执行的？
init() 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。

每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 init() 函数。同一个包，甚至是同一个源文件可以有多个 init() 函数。init() 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 init() 函数的执行顺序不作保证。

一句话总结： import –> const –> var –> init() –> main()

### Go 语言的局部变量分配在栈上还是堆上？
进行逃逸分析

- 如果局部变量在函数外部没有引用，则优先放到栈中；
- 如果局部变量在函数外部存在引用，则必定放在堆中；
- 如果局部变量在函数外部没有引用，但是作为`interface{}`传参，则逃逸到堆中-比如`fmt.Print()`，因为fmt.Println的函数参数为interface类型，编译期不能确定其参数的具体类型，所以将其分配于堆上。
- 如果局部变量在函数外部没有引用，但是变量比较大，-通过命令`ulimit -s`可以查看栈的限制；

### 2 个 interface 可以比较吗？
Go 语言中，interface 的内部实现包含了 2 个字段，类型 T 和 值 V，interface 可以使用 == 或 != 比较。

2 个 interface 相等有以下 2 种情况

- 两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）
- 类型 V 相同，且对应的值 V 相等。

### 两个 nil 可能不相等吗？
可能

接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。

两个接口值比较时，会先比较 T，再比较 V。
接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。
```
func main() {
	var p *int = nil
	var i interface{} = p
	fmt.Println(i == p) // true
	fmt.Println(p == nil) // true
	fmt.Println(i == nil) // false
}
```
上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为(T=*int, V=nil)，i 与 p 作比较时，将 p 转换为接口后再比较，因此 i == p，p 与 nil 比较，直接比较值，所以 p == nil。

但是当 i 与 nil 比较时，会将 nil 转换为接口 (T=nil, V=nil)，与i (T=*int, V=nil) 不相等，因此 i != nil。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。

### 函数返回局部变量的指针是否安全？
不安全会被分配到堆上，逃逸分析

### 非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？
一个T类型的值可以调用为`*T`类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型*T声明的方法。
反过来，一个*T类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型*T自动隐式声明一个同名和同签名的方法。
哪些值是不可寻址的呢？

字符串中的字节；
map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；
常量；
包级别的函数等。
举一个例子，定义类型 T，并为类型 *T 声明一个方法 hello()，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。
```
type T string

func (t *T) hello() {
	fmt.Println("hello")
}

func main() {
	var t1 T = "ABC"
	t1.hello() // hello
	const t2 T = "ABC"
	t2.hello() // error: cannot call pointer method on t
}
```
### golang的interface
接口的作用

接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。